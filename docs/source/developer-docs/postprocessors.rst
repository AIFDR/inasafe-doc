.. _postprocessors:

Postprocessors
==============

This document explains the purpose of postprocessors and lists the
different available postprocessor and the requirements each has to be
used effectively.

.. note:: This document is still a work in progress.

What is a postprocessor?
------------------------

A postprocessor is a function that takes the results from the impact function
and calculates derivative indicators, for example if you have an affected
population total, the Gender postprocessor will calculate gender specific
indicators such as additional nutritional requirements for pregnant women.

InaSAFE works by creating an intermediary vector layer that contains result of the aggregation done for your impact analysis. For example if you are doing a flood impact on OSM buildings and using an aggregation layer with few polygons, the intermediary layer will contain the the number of buildings flooded for each aggregation polygon. It is recommended, for understanding purpose, to turn in in InaSAFE options "Show intermediate layers generated by the post processing" and inspect the attributes table. If no aggregation layer is given, the area of interset will be used to create one polygon layer.

Creating postprocessors
-----------------------

Adding a new postprocessor is as simple as adding a new class called
Xxxxxx Postprocessor that inherits AbstractPostprocessor with 2 mandatory
methods (process, description), 2 optional ones and as many indicators as you
need.

the minimal class could look like this:
::

    class MySuperPostprocessor(AbstractPostprocessor):
        def __init__(self):
            AbstractPostprocessor.__init__(self)

        def description(self):
            return 'mydescription'

        def setup(self, params):
            AbstractPostprocessor.setup(self, None)
	   

        def process(self):
            AbstractPostprocessor.process(self)
	    self._calculate_my_indicator()

        def clear(self):
            AbstractPostprocessor.clear(self)

        def _calculate_my_indicator(self):
            x = 5
            A = 0.5
            myResult = 10 * x / A
            self._append_result('My Indicator', myResult)

After that you need to import the new class into postprocessor_factory and
update AVAILABLE_POSTPROCESSORS to include the postprocessor prefix (e.g.
MySuper if the class is called MySuperPostprocessor and its human readable
name)
::

   from mysuper_postprocessor import MySuperPostprocessor

    AVAILABLE_POSTPTOCESSORS = {'Gender': 'Gender',
                            'Age': 'Age',
                            'Aggregation': 'Aggregation',
                            'BuildingType': 'Building type',
                            'AggregationCategorical':
                            'Aggregation categorical',
                            'MinimumNeeds': 'Minimum needs',
                            'MySuper': 'My Super Postprocessor'
                            }

::
    
    from mysuper_postprocessor import MySuperPostprocessor
    
    AVAILABLE_POSTPTOCESSORS = {'Gender': 'Gender',
                            'Age': 'Age',
                            'Aggregation': 'Aggregation',
                            'BuildingType': 'Building type',
                            'AggregationCategorical':
                            'Aggregation categorical',
                            'MinimumNeeds': 'Minimum needs',
                            'MySuper': 'My Super Postprocessor'
                            }

As last step you have to update or add the *parameters* variable to the impact
functions that you want to use the new postprocessor. This will need to include
a dictionary of the available postprocessors as shown below.

::

    parameters = {
            'thresholds': [0.3, 0.5, 1.0],
            'postprocessors':
                {'Gender': {'on': True},
                 'Age': {'on': True,
                         'params': {
                            'youth_ratio': defaults['YOUTH_RATIO'],
                            'adult_ratio': defaults['ADULT_RATIO'],
                            'elder_ratio': defaults['ELDER_RATIO']
                            }
                        },
                  'MySuper': {'on': True}
                 }
            }

or as a minimum:
::

    parameters = {'postprocessors':{'MySuper': {'on': True}}}

If your post processor runs successfully and produces a result, this result will be appended to the Analysis result. You can use one of the impact function (e.g. : flood_OSM_building_impact) to add your test processor and test it. You should see a section containing the result of your super postprocessor:

.. figure:: /static/post_processor_test_result.png
   :scale: 30 %
   :align: center

For implementation examples see AgePostprocessor, GenderPostprocessor and BuildingTypePostprocessor which
both use mandatory and optional parameters

Types of aggregation
--------------------

* statistics_type = 'sum'
* statistics_type = 'class_count'

TBA


Brief Review of BuildingTypePostprocessor
-----------------------------------------

It is interesting to review some of the code in this post processor that is used to produce a report of affected buildings by type. The setup method is called for each aggregation polygon. It is called with all the necessary parameters that are needed by the process method to classify buildings by type.

::
  
    def setup(self, params):
        """Intialises parameters.
        """
        AbstractPostprocessor.setup(self, None)
        if (self.impact_total is not None or
                self.impact_attrs is not None or
                self.target_field is not None or
                self.valid_type_fields is not None or
                self.type_fields is not None):
            self._raise_error('clear needs to be called before setup')

        self.impact_total = params['impact_total']
        self.impact_attrs = params['impact_attrs']
        self.target_field = params['target_field']
        self.valid_type_fields = params['key_attribute']

* impact_total: the total number of buildings that are contained in the polygon
* impact_attrs: all attributes for all the features contained in the polygon
* target_field: attribute name used to detect the status of the building. In the case of the flood impact (flood_OSM_building_impact), the attribute is INUNDATED. This attribute was set and written as part of the keywords by the impact function.
* key_attribute: attribute name that is used to get the type of the building. This can either be set by the impact function or the default name 'type' will be used. Note: key_attribute is for now only available for the BuildingType processor. To adjust/review this, please refer to postprocessor_manager class.


Output
------
Dock.postproc Output will hold the result datastructure (shown below) of all
the postprocessors.
The structure is then parsed by Dock._postProcessingOutput() and
stored in the impact layer's keywords.
If a postprocessor generates no output (for example due to calculation errors),
then it will just be skipped from the report.

Data structure of results
.........................
::

    {'Gender': [
        (QString(u'JAKARTA BARAT'), OrderedDict([(u'Total', {'value': 278349, 'metadata': {}}),
                                                 (u'Females count', {'value': 144741, 'metadata': {}}),
                                                 (u'Females weekly hygiene packs', {'value': 114881, 'metadata': {'description': 'Females hygiene packs for weekly use'}})])),
        (QString(u'JAKARTA UTARA'), OrderedDict([(u'Total', {'value': 344655, 'metadata': {}}),
                                                 (u'Females count', {'value': 179221, 'metadata': {}}),
                                                 (u'Females weekly hygiene packs', {'value': 142247, 'metadata': {'description': 'Females hygiene packs for weekly use'}})]))],
     'Age': [
        (QString(u'JAKARTA BARAT'), OrderedDict([(u'Total', {'value': 278349, 'metadata': {}}),
                                                 (u'Youth count', {'value': 73206, 'metadata': {}}),
                                                 (u'Adult count', {'value': 183432, 'metadata': {}}),
                                                 (u'Elderly count', {'value': 21990, 'metadata': {}})])),
        (QString(u'JAKARTA UTARA'), OrderedDict([(u'Total', {'value': 344655, 'metadata': {}}),
                                                 (u'Youth count', {'value': 90644, 'metadata': {}}),
                                                 (u'Adult count', {'value': 227128, 'metadata': {}}),
                                                 (u'Elderly count', {'value': 27228, 'metadata': {}})]))
        ]
    }
